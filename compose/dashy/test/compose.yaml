services:
  dashy:
    image: lissy93/dashy:${TAG:-latest}
    container_name: dashy
    restart: unless-stopped
    # Expose port directly only when PROXY_TYPE is not set (standalone dev mode).
    # When behind traefik or caddy-docker-proxy the port binding is omitted and
    # routing is handled entirely by proxy labels below.
    ports:
      - "${DASHY_PORT:-4000}:80"
    environment:
      NODE_ENV: production
    volumes:
      - ${MNT_DIR}/etc/dashy/conf.yml:/app/public/conf.yml:ro
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://127.0.0.1:80/"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 60s

    # ── Traefik labels (active when traefik is the PROXY_TYPE) ──────────────
    # Zero-downtime is achieved via the healthcheck: Traefik only routes to a
    # container once it is healthy, so rolling `docker compose up -d` will
    # start the new container, wait for it to pass its healthcheck, then drain
    # and remove the old one without dropping requests.
    labels:
      # Traefik
      traefik.enable: "${TRAEFIK_ENABLE:-false}"
      traefik.http.routers.dashy.rule: "Host(`${DASHY_HOST:-dashy.local}`)"
      traefik.http.routers.dashy.entrypoints: "websecure"
      traefik.http.routers.dashy.tls: "true"
      traefik.http.routers.dashy.tls.certresolver: "letsencrypt"
      traefik.http.services.dashy.loadbalancer.server.port: "80"
      traefik.http.services.dashy.loadbalancer.healthcheck.path: "/"
      traefik.http.services.dashy.loadbalancer.healthcheck.interval: "10s"
      # Caddy docker-proxy
      # caddy-docker-proxy reads these labels and hot-reloads caddy config with
      # zero downtime on every Docker event (container start/stop/update).
      caddy: "${CADDY_ENABLE:-false}"
      caddy.reverse_proxy: ""

    networks:
      - vnet-frontend

networks:
  vnet-frontend:
    external: true
